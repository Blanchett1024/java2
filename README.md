# 김동현 202130101
## 5월 8일 10주차
<br>

## 추상 클래스
- abstract method 추상 메소드<br>
- 메소드의 코드는 없고 원형만 선언 <br><br>
- abstract class 추상 클래스 <br>
- 추상 메소드를 가지며 abstarct로 선언된 클래스<br>
- 추상메소드 없이 abstact로 선언한 클래스 <br>
<br><br>
- 추상클래스는 객체를 생성하는게 아니라 상속을 위한 슈퍼 클래스로 활용하기위해 만든다 <br>
- 추상클래스는 추상 메소드를 통해서 서브클래스가 구현할 메소드의 원형을 알려주는 역할<br>
- 상속을 위해서 만드는 클래스 

### 특징
- 추상 클래스는 온전한 클래스가 아니기 떄문에 인스턴스를 생성할수 없음<br>
- Java p;          > 오류없음 추상클래스의 레퍼런스만 선언<br>
- p= new Java();   > 오류 추상클래스의 인스턴스(객체) 생성 불가<br>
- Shape obj = new Shape();  > 오류 추상클래스의 인스턴스(객체) 생성 불가<br>

### 추상 클래스의 상속
- 추상클래스를 상속받으면 추상클래스가 됨<br>
- 서브클래스도 abstract로 선언 해주어야함<br>
### 추상 클래스 구현
- 서브 클래스에서 슈퍼클래스의 추상메소드 구현(오버라이딩)<br>
- 추상 클래스를 구현한 서브클래스는 추상클래스가 아님<br>
- 추상클래스를 구현한 서브클래스는 인스턴스를 생성할수 있다 > 정상 클래스가 된다<br>
### 추상 클래스의 목적
- 상속을 위한 슈퍼클래스로 활용하는것<br>
- 서브 클래스에서 추상메소드 구현<br>
- 다형성 실현<br>
### 예시<br>
한 집단에서 여러 사람이 한가지 프로그램을 만들때 여러 개발자가 만들어놓은 
메소드 이름과 클래스 이름이 같을수있는 불상사가 일어남
그래서 팀장이 한 슈퍼 클래스를 만들어 제공해 각 직원이 이 클래스에 오버라이딩 해서 사용하라 .
추상 클래스를 상속해서 사용해 이름이 겹치는일을 방지할수 있다 

## 인터페이스의 필요성
전원 플러그에도 나라별 규격이 다르듯 소프트웨어에서도 적용된다
### 자바 인터페이스
- 구성요소 <br>
상수/추상메소드/디폴트메소드/프라이빗메소드/static 메소드 

- 인터페이스의 객체는 추상메소드 처럼 객체를 생성할수없다
### 안터페이스 상속
인터페이스에서는 다른 인터페이스를 상속할수있다 <br>
다중 상속이 가능하다 <br>
### 인터페이스 구현
인터페이스 구현은 implements 키워드를 사용하여 인터페이스의 모든 추상 메소드를 구현한 클래스를 작성하는 것을 말한다.<br><br>
예제 5-6 을 보아 
samsungphone 클래스에는 phoneinterface 인터페이스의 모든 추상 메소드를 구현했으며<br>
flash()메소드를 추가 작성하였다<br>
그리고 phoneinterface 인터페이스에 이미 구현되어있는 디폴트 메소드 printlogo()는 그대로 상속받아 사용했다 
### 인터페이스 구현과 동시에 슈퍼클래스 상속
스마트폰클래스는 칼크를 상속받고 폰인터페이스 인터페이스의 추상메소드를 모두 구현했다
이후 추가작성 메소드 스케듈 

## 6장 패키지 
### 패키지 개념과 필요성
하나의 자바 응용프로그램을 개발하기 위해 여러 개발자가 작없을 분담한다.
개발자 a b c 가 각자 동일한 이름의 tools.class라는 파일을 만들었다 가정해보자 . 파일의 중복 문제가 발생한다 이를 어떻게 해결해야할까?
Project 라는 이름의 패키지를 만들어 project 하위에 a b c 파일을 따로 만들면된다 
그렇게 되면 project / a / tools.class
project/ b / tools.class 이렇게 다른 파일로 인식하여 중복문제를 해결할수 있다
### 자바 패키지와 모듈이란
패키지 
- 서로 관련된 클래스와 인터페이스를 컴파일한 클래스 파일들을 묶어 놓은 디렉터리
- 하나의 으용ㅇ프로그램은 한개 이상의 패키지로 작성
- 패키지는 jar 파일로 압축할수 이음

모듈 
- 여러 패키지와 이미지등의 자우너을 모아놓은 컨테이너
- 하나의 모듈을 하나의 .jmod 파일에 저장

자바9부터 모듈화 도입
- 플랫폼의 모듈화 : 자바 9 부터 자바api 의 모든 클래스들을 패키지기반에서 모듈들로 완전히 재구성
- 응용프로그램의 모듈화 : 클래스들은 패키지로 만들고 다시 패키지를 모듈로 만듦 모듈 프로그래밍은 어렵고 복잡.


모듈하의 목적
- 자바 컴포넌트들을 필요에 따라 조립하여 사용하기 위함이다. 
- 세밀한 모듈화를 통해 필요없는 모듈이 로드되지 않게 하여 컴퓨터 시스템에 불필요한 부담을 줄인다 
- 특히 하드웨어가 빈약한 소형 iot 장치에서도 자바 응용프로그램이 실행되고 성능을 유지하게 한다 .

- 모듈화 작업은 매우 중요한 개념이며 소규모 프로젝트부타 적용해야 대형프로젝트 쉽게 도입,활용할수있음.







# 김동현 202130101
## 4월18일 9주차
<br>

## static 메소드의 제약조건
- static메소드는 오직 static멤버만 접근할수 있다<br>

static메소드는 객체가 생성되지 않은 상황에서도 사용이 가능하므로 객체에 속한 인스턴스 메소드, 인스턴스 변수등을 사용할수없고 static멤버들만 사용가능하다.

- static메소드는 this를 사용할수 없다<br>

static메소드는 객체없이도 존재하기때문에 static메소드에서 this를 사용할수없다
## final<br><br> 
### final 키워드의 3가지 용도
> 클래스 
- final이 클래스 앞에 사용되면 클래스를 상속받을수 없음을 지정한다
> 메소드
- final이 메소드 앞에 사용되면 이 메소드는 더이상 오버라이딩 할 수 없음을 지정한다
> 필드
- final로 피드를 선언하면 필드는 상수가 된다 
- 상수 필드는 한번 초기화 되면 더이상 값을 변경할수없다
- final 키워드를 public static 과 함께 선언하면 프로그램 전체에서 공유할수있는 상수가 된다.

# 5장 상속
<br>

## 상속의 필요성 
개발자가 공통적인 코드가 들어있느 여러개의 클래스를 작성할때 한 멤버를 수정하려할때<br> 그 멤버를 공통적으로 포함하고있는 다른 클래스의 멤버들도 함께 수정해주어야 한다 <br>
그때 상속을 이용하면 이문제는 간단히 해결된다 <br>여러 클래스의 공통된 코드를 추려 새로운 클래스를 작성해 묶고 <br>나머지 클래스를 상속 클래스로 선언하면 코드를 중복작성할필요없이 물려받기만 하면된다<br>
> 상속은 클래스사이에 코드중복을 제거하여 클래스를 간결하게 구현할수 있게 한다
## 상속의 장점 
- 클레스 사이의 멤버 중복선언 불필요
- 클래스의 계층적 분류로 클래스 관리 용이
- 클래스의 재사용과 확장을통한 소프트웨어 생산성 향상
## 클래스 상속과 객체
- 상속선언 extends 키워드 사용
- 부모클래스를 물려받아 자식클래스를 확장한다는의미
- 부모클래스 = 수퍼클래스(super class)
- 자식클래스 = 서브클래스(sub class) 
## 자바 상속의 특징
> 클래스 다중 상속 불허
- 하나의 클래스가 둘이상의 부모클래스를 동시에 상속받는 것을 말함.
- c++ 는 다중상속가능 
- c++ 는 다중상속으로인한 멤버가 중복생성되는 문제 있음.
- 부모 클래스간에 계층적 관계가 있을경우 중복된 멤버가 생성될수 있다.
- 모호성문제 :두 부모클래스에 동일한 이름의 멤버가 존재할경우 어떤부모의 멤버를 호출해야할지 모호해짐.
> 자바는 인터페이스의 다중상속허용 
- 다중상속과 유사한 기능을 제공함
> 모든 자바 클래스는 묵시적으로 Object클래스 상속받음
- java. lang.Object 는 모든 클래스의 부모 클래스 (슈퍼 클래스)

## 슈퍼 클래스의 멤버에 대한 서브클래스의 접근
- 슈퍼 클래스의 private 멤버 > 서브클래스에서 접근할수없음<br>
- 슈퍼 클래스의 디폴트 멤버 > 서브 클래스가 동일한 패키지에 있을때 접근가능<br>
- 슈퍼 클래스의 public멤버 > 서브 클래스는 항상 접근 가능<br>
- 슈퍼 클래스의 protect 멤버 같은 패키지 내의 모든 클래스 접근 허용 >>패키지 여부와 상관없이 서브 클래스는 접근가능

## 상속과 생성자
<br>

## 서브 클래스와 슈퍼클래스의생성자 호출및 실행
- 서브클래스의 객체가 생성될때 : 슈퍼 클래스 생성자와 서브클래스 생성자 모두실행
- 호출순서: 서브클래스의 생성자 먼저 호출 >슈퍼클래스 생성자 호출
- 실행순서: 슈퍼클래스의 생성자 먼저 실행 >서브클래스 생성자 실행

## 서브클래스에서 슈퍼클래스 생성자 선택
- 슈퍼 클래스와 서브 클래스 :각각 여러개의 생성자 작성가능
- 서브클래스의 객체가 생성될때 : 슈퍼 클래스 생성자 1개와 서브클래스 생성자 1개가 실행
- 서브 클래스의 생성자와 슈퍼 클래스의 생성자가 결정되는 방식
> 개발자의 명시적 선택
- 서브 클래스 개발자가 슈퍼클래스의 생성자 명시적 선택
- super()키워드를 이용하여 선택
> 컴파일러가 기본 생성자 선택
- 서브 클래스 개발자가 슈퍼 클래스의 생성자를 선택하지 않는 경우
- 컴파일러가 자동으로 슈퍼 클래스의 기본 생성자 선택
## super()를 이용하여 명시적으로 슈퍼클래스의 생성자 선택
- super() : 서브 클래스에서 명시적으로 슈퍼 클래스의 생성자 선택 호출
> 사용방식 
- super(parameter);
- 인자를 이용하여 슈퍼클래스의 적당한 생성자 호출
- 반드시 서브클래스 생성자코드의 제일 첫라인에 와야함 
- super()를 활용한 예제 SuperEX.java

<br>
****** 5-2 예제를 실행할때 오류 발생 이유 5-1 때 동일한 이름의 클래스가 존재하기때문에 5-1이나 5-2 클래스 이름 둘중하나를 바꿔줘야 정상적으로 실행됨.

## 업캐스팅 
> 하위 클래스의 레퍼런스는 상위 클래스를 가리킬수 없지만 상위클래스의 레퍼런스는 하위 클래스를 가리킬수 있다.
- 생물이 들어가는 박스에 사람이나 코끼리를 넣어도 무방
- 사람이나 코끼리 모두 생물을 상속받았기 때문
#### 업캐스팅이란? 
- 서브클래스의 레퍼런스를 슈퍼클래스레퍼런스에 대입
- 슈퍼클래스 러퍼런스로 서브클래스 객체를 가리키게 되는현상
<br>

class Person{ } //슈퍼 클래스 <br>
class Student extends Person{ }<br>
<br>
>Person p;<br>
Student s = new Student( );<br>
p = s; //업캐스팅<br><br>

업 캐스팅 예시
>person[] people = new person[3]<br>
people[0] = new student ("홍길동")<br>
people[1] = new student ("김영희") <br>
people[2] = new person ("이순신")<br>

- 여러 자식 클래스를 하나의 부모타입으로 다루기위해 사용한다
- 이렇게하면 공통된 타입으로 여러자식클래스를 한배열에 담을수있다
- 대신 접근은 person 수준에서만 가능하다

## 다운캐스팅
- 슈퍼 클래스 레퍼런스를 서브클래스 레퍼런스에 대입
- 업캐스팅된것을 다시 원래대로 되돌리는것 
- 반드시 명시적 타입변환 지정이 필요함
## 업캐스팅 레퍼런스로 객체 구별?
- 업캐스팅된 레퍼런스로는 객체의 실제타입을 구분하기 어려움
- 슈퍼 클래스는 여러 서브 클래스에 상속되기 때문
- p 가 person인지 student인지 professor 인지 구분하기 어려움
## instance of 연산자
### 객체 레퍼런스 instanceof 클래스 타입 
-레퍼런스가 가리키는 객체의 타입 식별 : 연산의 결과는 true/false의 불린 값으로 변환
## 메소드 오버라이딩 
- 서브 클래스에서 슈퍼클래스의 메소드 중복작성
- 슈퍼 클래스의 메소드 무력화, 항상 서버 클래스에 오버라이딩한 메소드가 실행되도록 보장됨
- 메소드 무시하기로 변역되기도함
- 오버라이딩 조건 > 슈퍼 클래스의 메소드의 원형(메소드 이름, 인자타입 및 개수 , 리턴 타입 )과 동일하게 작성

## 오버라이딩의 목적
- 오버라이딩으로 다형성 실현
- 하나의 인터페이스(같은이름)에 서로다른 구현
- 슈퍼클래스의 메소드를 서브 클래스에서 각각 목적에 맞게 다르게 구현
- 사례5-18 shape의 draw() 메소드를 line rect cicle 에서 오버라이딩하여 다르게 구현
## 동적 바인딩
- 실행할 메소드를 컴파일시에 결정하지않고 실행시에 결정하는것
- 자바에서는 동적바인딩을 통해 오버라이딩된 메소드가 항상 실행되도록 보장한다.
## 오버로딩과 오버라이딩
| 비교요소 | 오버로딩 | 오버라이딩 |
|---|---|---|
| 선언 | 같은 클래스나 상속관계에서 동일한 이름의 메소드 중복작성 | 서브클래스에서 슈퍼클래스에 있는 메소드와 동일한 이름의 메소드 재작성 |
| 관계 | 동일한 클래스 내 혹은 상속 관계 | 상속관계 |
| 목적 |이름이 같은 여러개의 메소드를 중복선언하여 사용의 편리성 향상 | 슈퍼클래스에 구현된 메소드를 무시하고 서브클래스에서 새로운기능의 메소드를 재정의하고자함 |
| 조건 |메소드이름은 반드시 동일함 메소드의 인자의 개수나 인자의 타입이 달라야 성림 | 메소드의 이름 인자의 타입 인자의 개수 리턴타입등이 모두동일하여야성림 |
| 바인딩 |정적바인딩 컴파일시에 중복된 메소드 중호출되는 메소드 결정 | 동적바인딩 실행시간에 오버라이딩된 메소드 찾아 호출 |
<br><br><br>

# 김동현 202130101
## 4월 17일 7주차 
<br>

## 생성자
생성자는 객체가 생성될때 초기화를 위해 실행되는 메소드<br>
## 생성자의 특징
- 생성자의 이름은 클래스 이름과 동일하게 지어야함<br>
- 생성자는 몇개가 있어도 상관없다<br>
- 매개변수의 개수 혹은 매개변수의 데이터 타입이 다르면 된다<br>
## 기본 생성자<br>
기본생성자란 매개변수가 없고 또한 실행코드가 없어 아무일도하지않고 단순 리턴하는 생성자 이다 디폴트 생성자라고도 부른다.<br>
## 기본생성자가 자동으로 생성되는 경우 
생성자가 없는 클래스는 있을수 없으며, 클래스에 생성자가 하나도 선언되어 있지 않은경우에는 컬파일러는 기본생성자를 자동으로 생성한다
## 기본생성자가 자동으로 생성되지 않은경우 
생성자가 하나라도 존재하는 클래스 에는 컴파일러가 기본생성자를 자동으로 생성해주지않는다 
## this 레퍼런스 
객체 자신에 대한 레퍼런스, 컴파일러에 의해 자동으로 관리되므로 개발자는 사용하기만 하면됨
## this 레퍼런스의 활용
- this ()로 다른생성자 호출
- 같은 클래스의 다른 생성자 호출
- 생성자 내에서만 사용가능
- 생성자 코드의 제일 앞에 잇어야함
## 객체배열
객체에 대한 레퍼런스 배열
## 자바의 객체배열만들기3단계
- 1.배열 레퍼런스 변수선언
- 2.레퍼런스 배열생성
- 3.배열의 각원소 객체생성
## 배열의 원소 객체 접근
배열c 의 i 번째 객체에 접근하기위해서 c[i]레퍼런스를 사용한다
- circle 배열만들기 예제 CircleArray.java
## 메소드
자바의 메소드는 클래스의 멤버 함수로서 그림4-18 의 형식을 가지며 접근지정자를 선언한다는점외에 c/c++함수와 동일하다 
> 메소드는 클래스안에 존재해야한다
## 접근지정자 
접근지정자: 다른 클래스에서 메소드를 접근할수있는지 여부선언<br>
public/private/protected/디폴트(접근지정자 생략)<br>
## 리턴타입
리턴타입: 메소드가 리턴하는값의 데이터타입<br>
int/double/void 등
## 인자 전달 
## 기본타입의 값이 전달되는 경우 
매개 변수가 byte int char double 등 기본타입으로 선언되는 경우 호출기(caller)가 건네는 값이 메소드의 매개변수에 복사되어 잔달한다 실제 인자값은 변경되지않는다 
## 객체가 전달되는 경우 
메소드의 매개 변수가 클래스타입인경우 객체가 아니라 객체의 레퍼런스값이 전달된다
메소드 호출시 객체가 전달되는경우 객체에 대한 레퍼런스만 전달되지 객체가 통채로 복사되지않는다 
## 배열이 전달되는경우
배열이 전달되는경우도 객체가 전달되는경우와 동일하게 배열이 통채로 전달되는것이아니라 배열에대한 레퍼런스만 전달된다 
## 메소드 오버로딩 
자바에서는 클래스내에 이름이같지만 매개변수의 타입이나 개수가 서로다른 여러개의 메소드를 작성할수있다.<br>
 메소드 오버로딩=메소드 중복. <br>
 메소드오버로딩은 다형성의 한종류이다 
## 메소드 오버로딩의 조건
- 메소드이름이 동일하여야한다
- 메소드매개변수의 개수나 타입이서로달라야한다
- 메소드의 리턴타입과 접근지정자역시 메소드 오버로딩과 관계없다.

### 객체치환시 주의할점 
> 객체의 치환은 객체를 복사하는것이아니다 

## 객체의 소멸
- new로 할당받은 객체와 메모리를 jvm으로 되돌려주는 행위
- 자바는 객체소멸연산자 없음
- 객체소멸은 jvm의 고유한 역할
- c/c++에서는 할당받은 객체를 개발자가 프로그램내에서 삭제해야함
- c/c++의 프로그램작성을 어렵게 만드는 요안 
- 자바에서는 사용하지않는 객체나 배열을 돌려주는 코딩 책임으로부터 개발자 해방됨
## 가비지
할당받은 객체나 베열 메모리중에서 더 이상 사영하지않게된 메모리를 가비지라고부른다.<br>
자바플랫폼은 참조하는 레퍼런스가 하나도없는 객체나 배열을 가비지로 판단한다<br>
왜냐하면 이객체는 프로그램에서 더이상 접근할수없게 되았기 떄문이다 
## 가비지 컬렉션
가비지가 많아지면 응용프로그램에서 할당해줄수있는 가용메모리의 양이 줄어들기떄문에 가용 메모리공간이 일정수준 이하로 줄어들면 자바 가상기계는 가비지를 회수하여 가용메모리 공간을 늘린다 
이것을 가비지컬렉션이라고 부른다 
## 가비지컬렉션 강제수행 
system 또는 runtime 객체의 gc()메소드를 호출하여 자바플랫폼에 가비지 컬렉션을 요청할수있다 <br>
그러나 이문장을 호출한다고해서 즉시 가비지컬렉션이 작동되는것은 아니고 가비지컬렉션이 필요하다는 강력한 제안을 하는것에 불과하다 자바 가상기계가 전적으로 판단하여 적절한 시점에 작동시킨다
## 자바의 패키지개념 
자바에서는 상호관련있는 클래스파일을 패키지에 저장하여 관리한다
패키지는 디렉토리 혹은 폴더와 같은개념이며 자바응용프로그램은 하나이상의 패키지로 구성된다

## 접근지정자
자바의 접근 지정자4가지 private protected public 디폴트(접근지정자 생략)
## 접근 지정자의 목적 
- 클래스나 일부 멤버를 공개하여 다른 클래스에서 접근 하도록허용
- 객체지향언어의 캡슐화 정책은 멤버를 보호하는것> 접근지정은 캡슐화에 묶인 보호를 일부해제할 목적으로 사용
- 접근지정자에따른클래스나 멤버의 공개범위

| private | 디폴트 | protected | public 
|---|---|---|---|
| 외부로부터 완벽차단 | 동일패키지에 허용 | 동일패키지와 자식클래스에 허용 | 모든클래스에 허용 |


## static 과 non-static

## non-static
- 멤버는 객체마다 별도 존재 -인스턴스 멤버
- 객체 생성시에 멤버 생성됨
- 객체생길때 멤버도 생성
- 객체생성후 멤버사용가능
- 객체가 사라지면 멤버도 사라짐
- 공유되지않음 - 멤버는 객체내에 각각공간유지 
## static
- 멤버는 클래스당하나 생성
- 멤버는 객체내부가 아닌 별도의 공간 생성
- 클래스 멤버라고 부름
- 클래스 로딩시에 멤버생성
- 객체가생기기전에 이미생성
- 객체가 생기기전에도 사용가능
- 객체가사라져도 멤버는사라지지않음
- 멤버는 프로그램이 종료될때사라짐
- 동일한클래스의 모든객체들에의해 공유됨

### non-static 멤버가 객체이름으로만 활용할수있는것과는 달리 static멤버는 객체이름이나 클래스이름으로 모두활용할수있다

중간고사 > 오류잡는 문제 ,코딩

173p 그림 참조

## static 활용
- 전역변수와 전역함수를 만들때 사용
- 공유멤버를만들때  > staric 으로선언한멤버는 클래스의 객체들사이에 공유
# 김동현 202130101
## 4월 10일 6주차

## 예외
실행중 오작동이나 예상치못한 상황 발생을 예외라고한다.

실행중 예외가 발생하면 자바 플랫폼이 가장먼저 알게되어 자바 응용프로그램에게 

예외를 전달하게하여 예외에 대응하게한다 

정수를 0으로 나눈경우

배열의 크기보다 큰 인덱스로 배열의 원소에 접근한 경우

정수를 읽는 코드를 실행하고있을떄 사용자가 문자를 입력한경우 등

## 예외 처리 
TRY - CATCH - FINALLY문

try { 예외가 발생할 가능성이 있는 실행문  try 블록 }
    
catvh{ 처리할 예외 타입선언}{ 예외처리문(catvh 블록)}

finally{ 예외 발생여부와 관계없이 무조건 실행되는 문장(finally 블록 생략가능) }

- 예외클래스 자주발생하는 예외 117p 표3-1 참조 


## 클래스와 객체 
클래스 >> 객체의 모양을 선언한 틀 

클래스 모양 그대로 생성된 실체 >> 객체

붕어빵 기계 >클래스 

붕어빵      >객체 

## 객체의 특징

### 캡슐화 
안을 들여다 볼수없게하는것 . 객체를 보호하는목적, 하지만 외부의 정당한 접속을 위해서 몇몇 부분만을 공개 노출시킨다 
- ex) tv ,리모콘의 버튼등 

### 상속
상속은 상위 개체의 속성이 하위개체에 물려져서 하위개체가 상위 개체의 속성을 모두가지는 관계 
- ex) 134p 그림 4-4 참조

### 다형성 
같은 이름의 메소드가 클래스 혹은 객체에 따라 다르게 구현되는것 

메소드 오버로딩: 한 클래스 내에서 같은 이름이지만 다르게 작동하는 여러메소드

메소드 오버라이딩: 슈퍼 클래스의 메소드를 동일한 이름으로 서브클래스마다 다르게 구현


## 객체 지향 언어의 목적
### 소프트웨어의 생산성 향상 
컴퓨터 산업 발전에 따라 소프트웨어의 생명주기 단축

소프트웨어를 빠른속도로 생산할 필요성 증대

### 실세계에 대한 쉬운 모델링
초기 프로그래밍 - 수학 계산/통계 처리등 처리과정,계산절차 중요

반면 

현대 프로그래밍 - 컴퓨터가 산업전반에 활용

실세계에서 발생하는 일을 프로그래밍

실세계에서는 절차나 과정보다 물체(객체)들의 상호작요응로 묘사하는것이 용이

### 객체지향언어

- 실세계의 일을 보다 쉽게 프로그래밍하기 위한 객체 중심적 언어

- 상속,다향성,객체,캡슐화 등 소프트웨어 재사용을 위한 여러 장치 내장

- 소프트웨어 재사용과 부분 수정 빠름

- 소프트웨어를 다시 만드는 부담 대폭 줄임

- 소프트웨어 생산성 향상

## 절차 지향 프로그래밍과 객체 지향 프로그래밍
### 절차 지향 프로그래밍 
- 작업 순서를 표현하는 컴퓨터 명령 집합
- 함수들의 집합으로 프로그램 작성
### 객체 지향 프로그래밍
- 컴퓨터가 수행하는 작업을 객체들간의 상호 작용으로 표현
- 클래스 혹은 객체들의 집합으로 프로그램 작성

- 136P 그림4-7 참조 


## 클래스와 객체
클래스 : 객체의 속성과 행위 선언 객체의 설계도혹은틀

객체: 클래스의 틀로 찍어낸 실체
- 프로그램 실행중에 생성되는 실체
- 메모리 공간을 갖는 구체적인 실체
- 인스턴스라고도 부름

### 사례

클래스 :소나타 자동차           객체 : 출고된 소나타 100대

클래스 : 벽시계                 객체 : 우리집벽에걸린 벽시계

클래스 : 책상                   객체 : 우리가 사용중인 실제 책상

## 클래스 
CLASS 키워드로 선언

멤버 : 클래스 구성요소. 필드와(멤버변수) 메소드(멤버함수)

클래스에 대한 public 접근 지정: 다른 모든 클래스에서 클래스 사용허락

멤버에 대한 public 접근 지정 : 다른 모든 클래스에게 멤버 접근 허용 
- 139p 그림4-10 참조

객체 생성과 활용 
- 객체 생성과 활용 예제 Circle.java
1.레퍼런스 변수선언

2.new 연산자로 객체 생성

3.객체 멤버 접근

- 클래스 만들기 예제2 143p 예제 4-2 참조

## 생성자 
객체가 생성될때 초기화목적으로 실행되는 메소드

객체가 생성되는 순간에 자동 호출
### 생성자의 특징
- 생성자의 이름은 클래스의 이름과 동일하게 작성되어야한다
- 생성자를 여러개 생성할수있다
- 생성자는 객체를 생성할때 한번만 호출된다
- 생성자에 리턴 타입을 지정할수 없다
- 생성자의 목적은 객체가 생성될때 필요한 초기작업을 위함이다














# 김동현 202130101
## 4월 3일 5주차

## 반복문 for 문,while 문,do-while 문
## for 문 
초기문, 조건식, 반복후 작업 ,작업문 등을 기술해 조건식이 충족될때 까지 반복 작업문을 실행함 

- for문 예제 ForSample.java

## while문 
조건식과 작업문으로 이어져있으며 조건식이 참인동안 작업문을 반복한다 
- while문 예제  WhileSample.java 

## 교재에는 나오지않는 for문과 while문의 차이??
for문은 반복횟수가 명확히 정해져있을떄 ex 1에서 100까지 더해라 , 3단 구구단을 다 더해라 등

while문은 반복횟수가 정해져있지않는 연산을 해야할떄 >> 입력을 받아 연산을 행하는경우 //사용자의 숫자 입력을 받고 enter 를 받았을떄 반복을 시작하는 연산에 유리

## do-while문 
while문 과 동일한데 조건식이 반드시 필요하며 적어도 한번은 반드시 작업문이 실행되어야한다.
일단 작업문을 한번 실행하고 , 조건식을 따지기 시작한다 while 문과 순서가 다르다 
- do-while 문 예제      DoWhileSample.java  

문자열인 a 에 +1 을 해서 아스키값을 올려 a+1 =b 와 같은 연산을 이용함 
그렇게 a 가 가진 아스키값이 z 가 될떄까지 반복하여 a부터 z까지 출력하는 프로그램이 된다 

## 중첩 반복문.  
반복문안에 다른 반복문을 만들수 있다.

반복은 몇번이고 중첩할수있지만 너무많은 중첩반복은 프로그램 구조를 복잡하게 하므로 2중 ,3중정도가 적절하다 

- 중첩반복문을 이용해 구구단 출력하는 프로그램  NestedLoop.java

for문안에 for문을 넣는 중첩for문에서 정수 i를 많이 넣는데 여러정수를 쓸경우 i 다음 알파벳인 j ,k 등을 이용하는것이 보편적 

## continue문 
반복문을 빠져나가지않으면서 즉시 다음반복으로 넘어가려 할때 사용된다 
- continue문 예제     ContinueSample.java

## break문 
하나의 반복문을 즉시 벗어날떄 사용한다

break문이 실행되면 현재의 반복문을 벗어나 다음코드로 실행이 이어진다 break문은 단하나의 반복문만 벗어나므로 중첩반복문의 경우엔 break문을 여러번 사용해주어야한다
- break문 예제    BreakSample.java

 문자열을 입력받아 Stringequals()를 이용하여 true가 나올경우 break로 반복문을 벗어나는 프로그램 

## java 배열 
연속적은 자료구조 . 배열에는 같은종류의 데이터들이 순차적으로 저장된다. 그냥 정수 10개를 선언하는 경우와 배열을 이용해 "순차적으로" 10개의 정수로 구성된 배열을 선언하는것은 확연히 다르다

 int i[] = new int[10] > 10개의 정수로 이루어진 배열 선언

 int i0,i1,i2,i3,i4,i5... ; 10개의 정수를 따로 선언하기 
## 배열 생성
배열을 생성하는 방법은 레퍼런스 변수선언,배열 생성의 두단계로 이루어진다 

### 레퍼런스 변수선언 
int intArray [];

int >배열타입  

intArray > 배열에대한 레퍼런스 변수 

[] > 배열선언 

### 배열생성 
intArray = new int [5];

intArray > 배열에 대한 레퍼런스 변수 

new > 배열생성 

int >타입 

[5] >원소의 개수 

- 배열 예제 Array.java

## 배열 초기화 
int intArray[]= {1,2,3,4};

{} 를 이용해 초기화된 배열을 만들수있으며 배열의 크기는 {} 안에있는 값의 개수로 정해진다

## 레퍼런스 치환과 공유 
int intArray[]=new int[5];

int myArray[]= intArray;

이처럼 intArray의 배열을 myArray가 공유하게 된다  myArray의 값을 변환하면 intArray 의 값도 변경된다 


## 배열의 크기 length 
- 배열의 크기를 출력하는 예제 ArrayLengthSample.java 

## 배열과 for-each문
배열의 크기만큼 루프를 돌며 반복한다 

int [] n={1,2,3,4,5};

for(int k:n ){ 반복문 }

## 2차원 배열 
앞서배운 1차원 배열과 동일하게 레퍼런스 변수 선언후 배열 생성의 과정을 가진다

int intArray [][]; 

2행 5열의 2차원배열

intArray = new int [2][5];

1차원 배열과 동일하게 배열 선언과 생성을 동시에 할수 있다 

int intArray[][] = new int[2][5];

## 2차원배열의 초기화
2차원 배열을 선언할떄 각원소를 초기화할수있다 이떄 ,자동으로 초기화된 배열이 생성된다 

int intArray[][] = { {0,1,2},{3,4,5},{6,7,8}}  >> 3x3 크기의 배열생성 

배열 리턴....


# 김동현 202130101 
## 3월 27일 4주차 
## java
### 장점 
다른 언어 들은 자체적 으로 멀티스레드를 지원 하지않는 것 들이 많아 운영체제의 도움을 받는데에 반해 자바는 운영체제 없이 자체적 으로 멀티스레드 프로그래밍이 가능하다.

자바는 번거로운 메모리 반환과정을 자동으로 변환 해주는 가비지 컬렉션 이라는 기능이 있음. 
### 단점 
하지만 가비지 컬렉션이 실행도중 예상할 수 없는 시점에 알아서 실행되므로 프로그램 실행이 일시적으로 중단되는 현상이있어 실시간 응용시스템에 이용하기엔 적합하지않다.  

클래스 파일은 엄밀히 따지면 기계어가 아니다 . 그러므로 c나 c++ 보다는 실행 속도가 느리다. 최근 jtt컴파일링 기법등 의 방식으로 실행성능이 개선되긴했다. 


소스코드 > 우리가사용하는 java 코드 / 사람이 읽을수있는 고수준 언어 

바이트코드 javac가 소스코드를 변환한 중간코드 /cpu 가 직접 실행할수는 없음 jvm (java virtual machine )이 실행 해줘야함 / 기계어와 다르게 플랫폼 독립적  여러 플랫폼에서 동일하게 실행가능 

어디에서 실행되느냐에 따라서 jvm이 해석하고 코드를 변환해서 알아서 기계어로 변환해서 보여줌 

기계어 >cpu가 직접 실행할수있는 0과1로 구성된 이진코드 

# 2장 자바프로그램의 기본구조
## 식별자의 명명규칙
공백 사용 xx 

특수문자 사용 x (_ &)예외 

한글 x if while class 등 자바언어의 키워드는 식별자로 x

첫글자 숫자 x 

대소문자 구별함 

길이제한 x 

불린 리터럴 -true false 널 리터럴 -null 은 사용 x 


파일이름이 같은 파일이 존재할수있는 이유 > 파일 이름은 경로상에 있는 모든 파일들을 포함하는것이기 때문에 경로가 한개라도 다르다면 최종 파일이름이 같더라도 다른 파일임 . 

위에서 말했듯이 파일명은 경로상에 있는 모든 파일들이 이어져 포함되는것이기 떄문에 경로상에있는 모든 파일들에 식별자 명명규칙이 적용된다 한개의 파일경로에도 한글이 있으면 안된다 등.

$ > 임시파일에 사용함/ 첫글자에 _이 오면 보통 숨기는 파일에 사용   >>>> 잘 사용하지않음 

## 자바의 데이터 타입 8개 > 4가지  
논리타입 boolean 

문자타입 char 

정수타입 byte short int long

실수타입 float double

리터럴 .. 프로그램에 직접 표현한 값  int n = 15;   >여기에서는 15를 의미 

자바는 왜 참조 자료형을 (reference)쓸까?

안정성 

보안강화 포인트를 사용하면 메모리주소를 직접 조작할수 있기떄문에 오버플로우가 일어날수있다 > 보안취약점이 생길수있음  

다중플랫폼지원 자바는 jvm에서 실행되기때문에 os 에따라 메모리관리방식이 달라져도 영향받지않음 레퍼런스를 사용하면 jvm이 메모리관리를 해주므로 os영향받지않고 같은코드를 실행할수있다 

## 메모리의 구조 힙 /스택 
힙 - 선입선출 /스택- 쌓는 방식 나중에 들어온게 먼저나감 

힙이 스택을 침법하면 힙 오버 플로우  스택이 힙을 침범하면 스택 오버 플로우

변수>프로그램 실행중 값을임시로 저장하기위한 메모리공간/변경될수있음   

변수의 선언 >데이터타입에서 정한 크기의 메모리를 할당 

상수선언 final 키워드 사용.선언할때 초기값 지정 실행중 값의 변경 x

fianl double PI = 3.141592; 

상수선언/데이터타입/상수이름/초기화  상수선언은 항상 초기화 해줘야함

- 원의 면적을 구하는 프로그램  CircleArea.java

## VAR 키워드 
데이터 타입을 생략하고 변수선언을 할수있다.

컴파일러가 알아서 추론하여 변수타입을 결정 

변수선언할떄 초기값을 지정하지않으면 컴파일 오류가 일어남 

메소드 내부에 선언되는 지역변수에만 사용가능 하고 

클래스 내부에 선언되는 변수.객체가생성될때 함께 만들어지는 변수.   >>클래스필드에서는 사용될수 없다 

명시형 자료형 INT STRING DOUBLE 등과 함께 사용하는것이 좋다

가독성이 유지될수 있게 사용하여야 좋다

상수를 적극적으로 사용해서 코드의 안정성을 높히는 편이 좋다 

println >> 그냥 print 랑 기능적으로 같은데 ln 의 역할이 \n 임 줄바꿈을 한번 해줌 
 
## 타입변환 >특정 데이터 타입의 값을 다른데이터타입의 값으로 변환 

자동 타입변환 >컴파일러에의해 원래의 타입보다 큰타입으로 자동변환 

강제 타입변환 > 개발자가 직접 변환 .데이터 손실 발생가능


## system.in 
가장 기본 표준입력 스트림객체 

입력되는 키를 바이트(문자 x)로 리턴하는 저수준 스트림

바이트를 문자나 숫자로 변환하는 어려움이있음 

## scanner 
읽은 바이트를 문자 정수 실수 불린 문자열등 다양한 타입으로 변환하여 리턴 

객체를 생성해서 사용 

키보드에 연결된 system.in에게 키를 읽게하여 원하는 타입으로 변환하여 리턴 

입력되는 키 값을 공백으로 구분되는 토큰단위로 읽음 

공백문자 "\tab \n \r 등 (페이지 나누기 폼 피드 프린트 등에서 사용)

- 정수를 입력받아 몇시간 몇분 몇초인지 출력하는 프로그램  ArthmeticOperator.java
## 연산자 
주어진 식을 계산하여 결과를얻어내는 과정 >연산

하나의 식에는 피연산자 연산자 피연산자가 존재한다 

연산종류 증감/산술/시프트/비교/비트/논리/조건/대입 

- 두수의 차이를 구하는 프로그램  TermaryOperator.java
## 조건문 
 ## 단순if문 if-else문 

조건식이 참이면 if 내부의 실행문장이 실행 ,거짓이면 if 문을 벗어남

## if-else 문 

조건식이 참이면 실행문장1 을 실행, 거짓이면 실행문장 2를 실행후 문장을 벗어남 

## 다중 if-else 문 if-else 가 연속되는것 

여러개의 조건문을 가지고 ,조건식이 참인경우 해당하는실행문장을 실행한 후 다중if-else 문을 벗어남 .

앞의 조건문이 모두 거짓인경우 else의 실행문장을 실행후 다중if-else 문을 벗어남 

* 조건문이 너무많은 경우엔 후술할 switch문을 사용하기를 권장함

## 중첩 if-else 문 

if문이나 if-else 문혹은 ekse 문의 실행문장 안에 또다시 if 문,if-else 문등을 내포할수있다 .
 
## switch문 

식을먼저 계산하고 그결과값과 일치하는 case문으로 분기하여 실행문장을 실행한후 break를만나면 switch문을 벗어난다 

만일 어떤case문의 값과도 같지않은경우가 나올경우 default문으로 분기하여 실행문장을 실행한다 . default문은 생략할수있다. 

switch문에서 break문의 역할과 중요성..


# 김동현 202130101
## 3월 20일 3주차

프로젝트 생성하는 방법 위에 검색창에 >create java project 선택 no build tool 선택하고 폴더 선택 해야함 >>> 워킹 디렉토리를 선택 하면 그안에 디렉토리를 생성함.

src  안에 새로운 클래스 생성 하기  

새로 깃허브에 연동하는 방법 

## 자바 묘듈화의 필요성 

자바 플랫폼 독립성 ,객체지향 , 자바의 모든변수나 함수는 클래스 내에서 선언된다 ..   클래스 내부에 클래스를 만들었다면 컴파일 후에 바이트 코드가 생성이 된다

클래스가 여러개 있다고 한들 배포해야하는데 사용하는 이용자는 여러개의 클래스 파일을 일일이 다운로드 받지않게하기위해 한개의 파일로 압축을 해서 배포함 >> 그 파일을 jar이라고함 

여러개의 클래스 파일이 각각 main()을 포함하는 것은 상관없으나 한개의 클래스 파일안에 2개이상의 main()은 존재할수없음 

# 김동현 202130101
## 3월13일 2주차 

 깃허브 에 파일 올리는 방법 .커밋해서 파일 올리는 방법 
# h1 tag 
## h2 
### h3 
#### h4
##### h5
###### h6

---

* 가가가
- 나나나
1. 가가가
2. 나나나
3. 다다다

```
라라라
```
